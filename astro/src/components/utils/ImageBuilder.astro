---
import { urlFor } from "../../utils/urlForImage";

export interface Props {
  source: string;
  cls?: string;
  alt: string;
  lqip: string;
  ratio: number;
  caption?: string;
  captionUrl?: string;
  w?: number;
  fit?:
    | "clip"
    | "crop"
    | "fill"
    | "fillmax"
    | "max"
    | "scale"
    | "min" /* More info: https://www.sanity.io/docs/image-urls#fit-45b29dc6f09f */;
  loading?: "eager" | "lazy";
  vert?: boolean;
  isDark?: boolean;
}
const {
  source,
  cls,
  alt,
  lqip,
  ratio,
  caption,
  captionUrl,
  w,
  fit,
  loading = "lazy",
  vert,
  isDark = false,
} = Astro.props as Props;

const pattern = /^image-([a-f\d]+)-(\d+x\d+)-(\w+)$/;
const decodeAssetId = (id: string) => {
  const [, assetId, dimensions, format] = pattern.exec(id);
  const [width, height] = dimensions.split("x").map((v) => parseInt(v, 10));
  return {
    assetId,
    size: { width, height },
    format,
  };
};
const imageSize = decodeAssetId(source);

const defaultWidths = [320, 640, 960, 1280];
let maxWidth = w ? w : 1280;

const widths = defaultWidths.filter((width) => width <= maxWidth);
---

<figure class="container">
  <div class:list={["wrapper", { "dark-border": isDark }, cls]}>
    <div style={`padding-bottom: ${100 / ratio}%`} aria-hidden="true"></div>
    <img class="lqip loading" src={lqip} alt="" aria-hidden="true" />
    <picture>
      {
        vert && (
          <source
            media={`(max-width: ${defaultWidths[2]}px) and (min-height: ${defaultWidths[1]}px) and (max-aspect-ratio: 3/2)`}
            srcset={urlFor(source)
              .auto("format")
              .fit(fit ? fit : "clip")
              .height(1280)
              .url()}
          />
        )
      }
      {
        widths.map((width) => (
          <source
            media={`(max-width: ${width}px)`}
            srcset={`${urlFor(source)
              .auto("format")
              .fit(fit ? fit : "clip")
              .width(width)
              .url()} ${width}w`}
          />
        ))
      }
      <img
        src={urlFor(source)
          .auto("format")
          .fit(fit ? fit : "clip")
          .width(maxWidth)
          .url()}
        alt={alt ? alt : ""}
        class="source"
        loading={loading}
        draggable="false"
      />
    </picture>
  </div>
  {
    caption && (
      <figcaption>
        {captionUrl ? (
          <a href={captionUrl} target="_blank" rel="noopener">
            <span>{caption}</span>
          </a>
        ) : (
          <span>{caption}</span>
        )}
      </figcaption>
    )
  }
</figure>

<style>
  .container {
    text-align: center;
    width: 100%;
    height: 100%;
  }
  .wrapper {
    position: relative;
    overflow: hidden;
    width: 100%;
    height: 100%;
  }
  img {
    display: block;
    position: absolute;
    width: 100%;
    height: 100%;
    inset: 0;
    object-fit: cover;
    object-position: center;
  }
  .lqip {
    filter: blur(10px);
  }

  .loading {
    animation: pulse 1000ms ease-in-out alternate infinite;
  }

  @keyframes pulse {
    from {
      opacity: 1;
    }

    to {
      opacity: 0.7;
    }
  }
  .source {
    opacity: 0;
    transition: opacity 400ms ease-out;
  }

  .dark-border {
    border: solid 2px rgb(var(--clr-wb-light) / 0.05);
    transition: border var(--modeswitch-transition-time);
  }
  body.lightmode .dark-border {
    border: solid 0px rgb(var(--clr-wb-light) / 0);
  }

  .border {
    outline: solid var(--stroke-w) rgb(var(--c-stroke));
    transition: outline var(--modeswitch-transition-time);
  }

  .round {
    border-radius: var(--sm-radius);
  }

  figcaption {
    transition: color var(--modeswitch-transition-time);
    margin-top: 0.2em;
  }
  .loaded {
    opacity: 1;
  }
  .instant {
    transition: none;
  }
</style>

<script>
  document.addEventListener("astro:page-load", () => {
    const sourceImages = document.querySelectorAll("img.source");
    const qlipImages = document.querySelectorAll("img.qlip");

    const handleImageLoad = (
      image: HTMLImageElement,
      bypassTransition = false
    ) => {
      if (bypassTransition) {
        image.classList.add("instant");
      }
      image.classList.add("loaded");
      image.removeEventListener("load", () =>
        handleImageLoad(image, bypassTransition)
      );
      image.removeEventListener("error", () =>
        handleImageLoad(image, bypassTransition)
      );
    };

    sourceImages.forEach((element) => {
      const image = element as HTMLImageElement;
      if (image.complete) {
        handleImageLoad(image, true);
      } else {
        image.addEventListener("load", () => handleImageLoad(image));
        image.addEventListener("error", () => handleImageLoad(image));
      }
    });
  });
</script>
